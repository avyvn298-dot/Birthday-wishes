<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Abdullah's 17th Birthday Quest</title>
<style>
  :root{
    --bg1:#0f1724;
    --bg2:#10304a;
    --ui:#d1f2ff;
    --accent:#ff6f61;
    --pixel-font: "Courier New", monospace;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--ui);font-family:var(--pixel-font);}
  .wrap{max-width:900px;margin:12px auto;padding:12px;text-align:center;}
  .title{font-size:20px;margin-bottom:6px;letter-spacing:1px}
  .dialogue-box{
    width: min(760px, 96%);
    margin: 6px auto;
    background: rgba(10,10,10,0.85);
    border:4px solid #111;
    padding:16px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    font-size:18px;
    line-height:1.4;
    border-radius:8px;
    text-align:left;
  }
  .dialogue-text{min-height:56px;white-space:pre-wrap;font-family:var(--pixel-font);font-size:18px;color:var(--ui)}
  .choices{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
  .btn{
    background:var(--accent); color:#fff; padding:8px 12px; border-radius:6px; border:none; cursor:pointer; font-weight:700;
    box-shadow: 0 3px 0 rgba(0,0,0,0.3);
  }
  .btn:active{transform:translateY(1px)}
  canvas{display:block;margin:12px auto;border:4px solid #0c2b3a;background:#08121a;border-radius:8px}
  .hud{display:flex;justify-content:space-between;align-items:center;max-width:760px;margin:0 auto;color:var(--ui);font-weight:700}
  .message-float{
    position:fixed;left:50%;transform:translateX(-50%);top:18%;
    background:rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;border:2px solid rgba(255,255,255,0.06);
    font-family:var(--pixel-font);font-size:16px;pointer-events:none;opacity:0;transition:opacity .2s;
  }
  .hidden{display:none}
  /* Responsive */
  @media (max-width:460px){
    .dialogue-text{font-size:16px}
    .title{font-size:18px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="title">🎮 Abdullah's 17th Birthday Quest — (Pixel Edition)</div>

    <div id="dialogue" class="dialogue-box" aria-live="polite">
      <div id="dialogueText" class="dialogue-text"></div>
      <div id="dialogueChoices" class="choices"></div>
      <div style="margin-top:8px;text-align:right"><button id="clickToContinue" class="btn hidden" aria-hidden="true">Continue</button></div>
    </div>

    <div class="hud hidden" id="hud">
      <div id="status">Name: <strong id="playerName">Abdullah Naveed</strong></div>
      <div id="score">Score: 0 / 17</div>
    </div>

    <canvas id="game" width="360" height="540" class="hidden" aria-label="Birthday game canvas"></canvas>

    <div id="finalBox" class="dialogue-box hidden" style="text-align:center">
      <div id="finalText" style="font-size:20px;font-weight:900"></div>
      <div style="margin-top:12px">
        <button id="replayBtn" class="btn">Play Again</button>
      </div>
    </div>
  </div>

  <div id="floatMsg" class="message-float" role="status"></div>

<script>
/* ===========================
   CONFIG - tweak here
   =========================== */
const NAME = "Abdullah Naveed";
const TARGET_SCORE = 17; // 17th birthday
const PLAYER_COLORS = {
  skin: "#f2d1b3",
  hair: "#2c1b10",
  shirt: "#2a9df4",
  pants: "#222"
};
const CANVAS_BASE_W = 360; // for scaling sprites
/* =========================== */

/* Dialogue data: each item is either text or a choice block.
   For choice blocks, provide choices array with {label, reply}. */
const script = [
  { type: "text", text: `Hi ${NAME}.` },
  { type: "text", text: `I know it's your birthday today 🎂` },
  {
    type: "choice",
    text: "Do you want your present?",
    choices: [
      { label: "Yes!", reply: "Bold move! We'll see if you deserve it..." },
      { label: "Nope", reply: "Not in the mood? Still, prove yourself anyway."},
      { label: "Let me think", reply: "Thinking? Good—decisions need quests."}
    ]
  },
  { type: "text", text: "First, a little challenge to prove you're the legend." },
  { type: "text", text: `Collect ${TARGET_SCORE} gifts and cakes to unlock your surprise!` },
  { type: "action", label: "Start Quest" }
];

/* ==========================
   Dialogue system
   ========================== */
const dialogueEl = document.getElementById("dialogue");
const textEl = document.getElementById("dialogueText");
const choicesEl = document.getElementById("dialogueChoices");
const clickContinue = document.getElementById("clickToContinue");
const hud = document.getElementById("hud");
const scoreEl = document.getElementById("score");
const playerNameEl = document.getElementById("playerName");
playerNameEl.textContent = NAME;

let scriptIndex = 0;
let typingTimer = null;
let charI = 0;
let isTyping = false;

function showNextScript() {
  choicesEl.innerHTML = "";
  clickContinue.classList.add("hidden");
  if (scriptIndex >= script.length) return;
  const node = script[scriptIndex++];

  if (node.type === "text") {
    typeText(node.text, () => {
      clickContinue.classList.remove("hidden");
      clickContinue.onclick = () => { clickContinue.classList.add("hidden"); showNextScript(); };
    });
  } else if (node.type === "choice") {
    typeText(node.text, () => {
      // render choice buttons
      node.choices.forEach(c=>{
        const b = document.createElement("button");
        b.className = "btn";
        b.textContent = c.label;
        b.onclick = () => {
          showFloatMessage(c.reply);
          // show reply briefly then continue
          typeText(c.reply, ()=> {
            setTimeout(()=>{ showNextScript(); }, 600);
          }, true);
        };
        choicesEl.appendChild(b);
      });
    });
  } else if (node.type === "action") {
    // final action button (Start Quest)
    const b = document.createElement("button");
    b.className = "btn";
    b.textContent = node.label;
    b.onclick = startGameUI;
    choicesEl.appendChild(b);
  }
}

function typeText(txt, done, override=false) {
  if (isTyping && !override) return;
  isTyping = true;
  textEl.textContent = "";
  charI = 0;
  const speed = 18; // ms per char
  clearInterval(typingTimer);
  typingTimer = setInterval(()=>{
    textEl.textContent += txt[charI++] || "";
    if (charI >= txt.length) {
      clearInterval(typingTimer);
      isTyping = false;
      if (done) done();
    }
  }, speed);
}

function showFloatMessage(msg, t=1400) {
  const el = document.getElementById("floatMsg");
  el.textContent = msg;
  el.style.opacity = 1;
  clearTimeout(el._t);
  el._t = setTimeout(()=>{ el.style.opacity = 0; }, t);
}

/* Start by showing script */
showNextScript();

/* ==========================
   GAME: canvas, sprites, logic
   ========================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: false });
let scale = 2; // pixel scale for sprites, adjusted later
function fitCanvas() {
  const available = Math.min(window.innerWidth * 0.96, 760);
  canvas.width = Math.floor(Math.min(available, 420));
  canvas.height = Math.floor(canvas.width * 1.4);
  scale = Math.max(2, Math.floor(canvas.width / CANVAS_BASE_W * 2));
}
window.addEventListener("resize", () => {
  fitCanvas();
  drawStatic(); // redraw background if needed
});
fitCanvas();

/* Pixel sprite drawing helper:
   sprite: 2D array of palette indices (0 = transparent)
   palette: array of color hex strings (index correspond)
   draw at x,y (top-left) scaled by 'scale' */
function drawPixelSprite(sprite, palette, x, y) {
  for (let yy=0; yy<sprite.length; yy++){
    for (let xx=0; xx<sprite[0].length; xx++){
      const v = sprite[yy][xx];
      if (!v) continue;
      ctx.fillStyle = palette[v];
      ctx.fillRect(x + xx*scale, y + yy*scale, scale, scale);
    }
  }
}

/* --- Tiny Abdullah sprite (12x12) palette indices:
   0 = transparent
   1 = skin
   2 = hair
   3 = shirt
   4 = pants
   5 = shoe
*/
const heroSprite = [
  [0,0,0,1,1,1,1,1,1,0,0,0],
  [0,0,1,1,1,1,1,1,1,1,0,0],
  [0,0,0,2,2,2,2,2,2,0,0,0],
  [0,0,2,2,2,2,2,2,2,2,0,0],
  [0,0,0,1,1,1,1,1,1,0,0,0],
  [0,0,3,3,3,3,3,3,3,3,3,0],
  [0,0,3,3,3,3,3,3,3,3,3,0],
  [0,0,4,4,4,4,4,4,4,4,4,0],
  [0,0,4,4,4,4,4,4,4,4,4,0],
  [0,0,0,5,5,0,0,5,5,0,0,0],
  [0,0,0,5,5,0,0,5,5,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0]
];

/* gift (6x6), cake (6x5), book obstacle (6x4) */
const giftSprite = [
  [0,2,2,2,2,0],
  [2,2,1,1,2,2],
  [2,1,3,3,1,2],
  [2,1,3,3,1,2],
  [2,2,1,1,2,2],
  [0,2,2,2,2,0]
];
const cakeSprite = [
  [0,0,4,4,0,0],
  [0,4,1,1,4,0],
  [4,1,2,2,1,4],
  [4,1,1,1,1,4],
  [0,4,4,4,4,0]
];
const bookSprite = [
  [0,6,6,6,6,0],
  [6,1,1,1,1,6],
  [6,1,1,1,1,6],
  [0,6,6,6,6,0]
];

/* Palettes: index -> color (use PLAYER_COLORS where appropriate) */
function paletteHero() {
  return [null, PLAYER_COLORS.skin, PLAYER_COLORS.hair, PLAYER_COLORS.shirt, PLAYER_COLORS.pants, "#333", "#a14a4a"];
}
const giftPalette = [null, "#fff0c8", "#ff2d55", "#ffd700", "#f8c8a0", "#000"];
const cakePalette = [null, "#fff0c8", "#ff6f61", "#ffe0b2", "#fff"];
const bookPalette = [null, "#fff0c8", "#e9e9e9", "#a1a1a1", "#d4d4d4", "#000"];

/* Player object */
const player = {
  w: heroSprite[0].length * 2, // will be scaled with scale when drawing
  h: heroSprite.length * 2,
  x: 140,
  y: 0,
  vx: 0,
  speed: 3,
  alive: true
};

/* Items array */
let items = []; // {x,y,type,vy}
let lastSpawn = 0;
let spawnInterval = 900; // ms
let score = 0;
let running = false;
let lastTime = 0;
let showMessages = [];
let victory = false;

/* draw background and static hud */
function drawStatic(){
  // simple starry background
  ctx.fillStyle = "#08121a";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // gradient floor
  const g = ctx.createLinearGradient(0,canvas.height*0.65,0,canvas.height);
  g.addColorStop(0,"rgba(255,255,255,0.02)");
  g.addColorStop(1,"rgba(0,0,0,0.3)");
  ctx.fillStyle = g;
  ctx.fillRect(0,canvas.height*0.65,canvas.width,canvas.height*0.35);
}

/* draw everything each frame */
function render(){
  drawStatic();

  // draw player (center bottom)
  player.drawX = Math.max(8, Math.min(canvas.width - (heroSprite[0].length*scale)-8, player.x));
  player.drawY = canvas.height - (heroSprite.length*scale) - 28;
  drawPixelSprite(heroSprite, paletteHero(), Math.round(player.drawX), Math.round(player.drawY));

  // draw items
  items.forEach(it=>{
    if (it.type === "gift") drawPixelSprite(giftSprite, giftPalette, Math.round(it.x), Math.round(it.y));
    if (it.type === "cake") drawPixelSprite(cakeSprite, cakePalette, Math.round(it.x), Math.round(it.y));
    if (it.type === "book") drawPixelSprite(bookSprite, bookPalette, Math.round(it.x), Math.round(it.y));
  });

  // draw score and small text on canvas
  ctx.fillStyle = "#d1f2ff";
  ctx.font = `${12}px ${"Courier New"}`;
  ctx.fillText(`Score: ${score} / ${TARGET_SCORE}`, 12, 18);
}

/* update positions */
function update(dt){
  // move player
  player.x += player.vx * player.speed;
  // clamp
  player.x = Math.max(4, Math.min(player.x, canvas.width - heroSprite[0].length*scale - 4));

  // spawn
  if (Date.now() - lastSpawn > spawnInterval) {
    lastSpawn = Date.now();
    spawnItem();
  }

  // update items
  for (let i = items.length -1; i>=0; i--){
    const it = items[i];
    it.y += it.vy * (dt/16);
    // collision check with player (rough box check)
    const px = player.drawX, py = player.drawY, pw = heroSprite[0].length*scale, ph = heroSprite.length*scale;
    const ix = it.x, iy = it.y, iw = (it.type==="book"?6:6)*scale, ih = (it.type==="cake"?5:6)*scale;
    if (iy+ih >= py && iy <= py+ph && ix+iw >= px && ix <= px+pw) {
      // collision
      if (it.type === "gift" || it.type === "cake") {
        score = Math.min(TARGET_SCORE, score+1);
        beep(900 - Math.random()*200, 0.06);
        pushMessage(collectMessage(score));
      } else if (it.type === "book") {
        score = Math.max(0, score-1);
        beep(220, 0.12);
        pushMessage("Ugh — a boring book! -1");
      }
      items.splice(i,1);
      scoreEl.textContent = `Score: ${score} / ${TARGET_SCORE}`;
      if (score >= TARGET_SCORE && !victory) {
        triggerVictory();
      }
      continue;
    }
    // remove if below
    if (it.y > canvas.height + 40) items.splice(i,1);
  }
}

/* spawn random item */
function spawnItem(){
  const x = Math.random() * (canvas.width - 40) + 8;
  const r = Math.random();
  let type = "gift";
  if (r > 0.85) type = "book";
  else if (r > 0.6) type = "cake";
  items.push({ x: Math.round(x), y: -30, vy: 1.4 + Math.random()*1.4, type });
}

/* collect messages */
function collectMessage(currScore){
  const lines = [
    "Nice catch! One more cake coming 🍰",
    "Sweet! Abdullah's stash grows!",
    "No emails today — birthday power!", 
    "Power up! Almost there!",
    "Legendary catch! Keep going!",
    "You're on fire — cake magnet!",
    "Looking pro, Abdullah!"
  ];
  // choose by score to add variety:
  return (currScore % 2 === 0) ? lines[currScore % lines.length] : lines[Math.floor(Math.random()*lines.length)];
}

function pushMessage(msg){
  showFloatMessage(msg, 1500);
}

/* main loop */
function loop(t){
  if (!running) return;
  const dt = t - lastTime || 16;
  lastTime = t;
  update(dt);
  render();
  if (!victory) requestAnimationFrame(loop);
}

/* controls: keyboard and touch */
document.addEventListener("keydown", (e)=>{
  if (!running) return;
  if (e.key === "ArrowLeft" || e.key === "a") player.vx = -1;
  if (e.key === "ArrowRight" || e.key === "d") player.vx = 1;
});
document.addEventListener("keyup", (e)=>{
  if (!running) return;
  if ((e.key === "ArrowLeft" && player.vx<0) || (e.key === "ArrowRight" && player.vx>0) || e.key === "a" || e.key === "d") player.vx = 0;
});

/* simple touch controls: left half and right half */
canvas.addEventListener("pointerdown", (e)=>{
  if (!running) return;
  const r = canvas.getBoundingClientRect();
  const cx = e.clientX - r.left;
  player.vx = cx < canvas.width/2 ? -1 : 1;
  e.preventDefault();
});
canvas.addEventListener("pointerup", (e)=>{
  if (!running) return;
  player.vx = 0;
});

/* start the game UI: hide dialogue, show canvas and HUD */
function startGameUI(){
  document.getElementById("dialogue").classList.add("hidden");
  hud.classList.remove("hidden");
  canvas.classList.remove("hidden");
  document.getElementById("finalBox").classList.add("hidden");
  // reset state then run
  resetGame();
  running = true;
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

/* reset game state */
function resetGame(){
  items = [];
  lastSpawn = 0;
  score = 0;
  victory = false;
  scoreEl.textContent = `Score: ${score} / ${TARGET_SCORE}`;
  player.x = Math.max(8, (canvas.width/2) - (heroSprite[0].length*scale)/2);
  player.vx = 0;
}

/* victory fireworks and final message */
function triggerVictory(){
  victory = true;
  running = false;
  // small victory sound
  beep(880, 0.12);
  setTimeout(()=>{ beep(1320, 0.08); }, 120);
  // show fireworks animation for a short period
  runFireworks(2000, ()=> {
    // show final screen
    document.getElementById("finalText").innerHTML = `🎉 <strong>HAPPY 17th BIRTHDAY, ${NAME.toUpperCase()}</strong> 🎂<br><small style="font-weight:600">Wishing you a year of joy, success, and endless cake 🍰</small>`;
    document.getElementById("finalBox").classList.remove("hidden");
    hud.classList.add("hidden");
  });
}

/* simple oscillator beep */
function beep(freq=440, dur=0.08){
  try {
    const ctxA = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctxA.createOscillator();
    const g = ctxA.createGain();
    o.type = "square";
    o.frequency.value = freq;
    o.connect(g);
    g.connect(ctxA.destination);
    g.gain.setValueAtTime(0.0001, ctxA.currentTime);
    g.gain.exponentialRampToValueAtTime(0.12, ctxA.currentTime + 0.01);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, ctxA.currentTime + dur);
    setTimeout(()=>{ o.stop(); ctxA.close(); }, dur*1000 + 50);
  } catch(e) { /* audio blocked or unsupported */ }
}

/* small fireworks using particles */
function runFireworks(duration=2000, done){
  const particles = [];
  const centerX = canvas.width/2, centerY = canvas.height/3;
  // create many particles
  for (let i=0;i<80;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = 1 + Math.random()*4;
    particles.push({
      x:centerX, y:centerY,
      vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      life: 100 + Math.random()*60,
      color: `hsl(${Math.floor(Math.random()*360)},80%,60%)`
    });
  }
  const start = performance.now();
  function fw(t){
    const elapsed = t - start;
    // clear small area
    drawStatic();
    // draw player and items a final time behind fireworks
    drawPixelSprite(heroSprite, paletteHero(), Math.round(player.drawX), Math.round(player.drawY));
    items.forEach(it=>{
      if (it.type === "gift") drawPixelSprite(giftSprite, giftPalette, Math.round(it.x), Math.round(it.y));
      if (it.type === "cake") drawPixelSprite(cakeSprite, cakePalette, Math.round(it.x), Math.round(it.y));
      if (it.type === "book") drawPixelSprite(bookSprite, bookPalette, Math.round(it.x), Math.round(it.y));
    });
    // update particles
    particles.forEach(p=>{
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.03; p.life--;
      ctx.fillStyle = p.color;
      ctx.fillRect(Math.round(p.x), Math.round(p.y), 3, 3);
    });
    if (elapsed < duration) requestAnimationFrame(fw);
    else { if (done) done(); }
  }
  requestAnimationFrame(fw);
}

/* Draw static initially */
drawStatic();

/* final screen replay button */
document.getElementById("replayBtn").onclick = ()=>{
  document.getElementById("finalBox").classList.add("hidden");
  // show dialogue again or go straight to game? we'll go straight to game if user wants
  startGameUI();
};

/* put playerName in HUD */
document.getElementById("playerName").textContent = NAME;

/* show initial hint floating */
showFloatMessage("Tip: Use arrow keys or tap left/right on screen to move.", 3000);

/* expose manual start for debug (useful during testing) */
window.startGameUI = startGameUI;

</script>
</body>
</html>
